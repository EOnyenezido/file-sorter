<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileSorter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">FileSorter</a> &gt; <a href="index.source.html" class="el_package">ExternalSorting</a> &gt; <span class="el_source">FileSorter.java</span></div><h1>FileSorter.java</h1><pre class="source lang-java linenums">package ExternalSorting;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * Sorts a large input file by splitting it into sorted temp files and merging them into a sorted output file.
 *
 * This class essentially takes in a large file, and uses an estimate of the free memory to split the file
 * into sorted chunks that fit in the free memory and saves these chunks as temp files.
 *
 * It then merges the sorted temp files using the merge k sorted lists algorithm to produce a final sorted file
 * */
public class FileSorter {
    private static int OBJ_OVERHEAD;
    private static Properties props;

    /**
     * Constructor for initializing an instance with custom properties.
     * Properties can be null if so it defaults to internal values.
     *
     * @param props Properties object containing maxTmpFiles, inputFile, outputFile,
     *              order, wordWrap and tmpFilesDirectory
     * */
<span class="fc" id="L26">    public FileSorter(Properties props) {</span>
<span class="fc" id="L27">        FileSorter.props = props;</span>
<span class="fc" id="L28">        String dataModel = System.getProperty(&quot;sun.arch.data.model&quot;);</span>
        // If unknown JVM bit model, default to 64 bits
<span class="pc bpc" id="L30" title="2 of 4 branches missed.">        boolean IS_64_BIT_JVM = dataModel == null || !dataModel.contains(&quot;32&quot;);</span>
<span class="pc bpc" id="L31" title="1 of 2 branches missed.">        int OBJ_HEADER = IS_64_BIT_JVM ? 16 : 8;</span>
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        int ARR_HEADER = IS_64_BIT_JVM ? 24 : 12;</span>
<span class="pc bpc" id="L33" title="1 of 2 branches missed.">        int OBJ_REF = IS_64_BIT_JVM ? 8 : 4;</span>
<span class="fc" id="L34">        int INT_FIELDS = 12;</span>
<span class="fc" id="L35">        OBJ_OVERHEAD = OBJ_HEADER + INT_FIELDS + OBJ_REF + ARR_HEADER;</span>
<span class="fc" id="L36">    }</span>

    /**
    * This method essentially attempts to estimate the available free memory.
    * It first calls the gc to clear up unused objects and then estimates the
    * free memory is the configured max memory -Xmx/mx minus the used memory
    *
    * @return The estimated free memory
    * */
    public static long getEstimatedFreeMemory() {
<span class="fc" id="L46">        System.gc(); // Call the garbage collector to free up memory first</span>

<span class="fc" id="L48">        Runtime currentRunTime = Runtime.getRuntime();</span>
        // Used memory is the currently allocated memory minus the free memory
<span class="fc" id="L50">        long usedMemory = currentRunTime.totalMemory() - currentRunTime.freeMemory();</span>

        // presumably free memory
<span class="fc" id="L53">        return Runtime.getRuntime().maxMemory() - usedMemory;</span>
    }

    /**
    * This method estimates a block size which is how much data we can read into memory at a chunk
    * It also ensures that this block size is not more than the free memory and not
    * excessively less than free memory such that it becomes inefficient
    *
    * @param fileSize The size of the input file to be processed
    * @param maxTmpFiles The maximum number of temp files to create
    * @param freeMemory The amount of JVM memory that is free and available for use
    *
    * @return The estimated size of a block which we can read into memory safely
    *
    * @throws Exception If the estimated block size is above the free memory then the file cannot be processed
    *                   unless the maxTmpFiles is increased
    * */
    public static long getEstimatedBlockSize(long fileSize, int maxTmpFiles, long freeMemory)
            throws Exception {
        // We make sure we are not creating more files than maxTmpFiles
<span class="fc bfc" id="L73" title="All 2 branches covered.">        long blockSize = fileSize / maxTmpFiles + (fileSize % maxTmpFiles == 0 ? 0 : 1);</span>

        // If the block size is greater than free memory, we cannot proceed with the configured
        // maxTmpFiles. Throw an error
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (blockSize &gt; freeMemory) {</span>
<span class="fc" id="L78">            throw new Exception(&quot;Cannot create enough temporary files to fit a sort file. Please check maxTmpFiles&quot;);</span>
        }

        // If the block size if far less than the free memory, we are creating to many
        // temporary files, so we increase it
<span class="fc" id="L83">        blockSize = Math.max(blockSize, freeMemory / 2);</span>

<span class="fc" id="L85">        return blockSize;</span>
    }

    /**
    * This method essentially estimates a string size in bytes
    * It estimates 2 bytes per character plus an object overheard
    * based on the JVM bit size
    *
    * @param str String for which to estimate size
    *
    * @return The estimated string size
    * */
    public static long getEstimatedStringSize(String str) {
<span class="fc" id="L98">        return (str.length() * 2) + OBJ_OVERHEAD;</span>
    }

    /**
    * This method sorts a chunk of words that are within the block size limit
    * and saves the sorted chunk to a temp file to clear up memory for the next chunk.
    *
    * @param unsortedLineChunk A list of words to sort and save in a temp file
    * @param comparator Comparator to use to sort the list of words
    * @param tmpDirectory Directory to save the sorted temp file
    *
    * @return The sorted temp file
    *
    * @throws IOException General IOException if unable to access any file(s)
    * */
    public static File sortAndSaveTempFile(List&lt;String&gt; unsortedLineChunk, Comparator&lt;String&gt; comparator,
        File tmpDirectory) throws IOException {
        // Sort the unsorted line chunk
<span class="fc" id="L116">        unsortedLineChunk.sort(comparator); // TODO - Compare with parallel sort</span>
        // Create a temp file and delete it on exit
<span class="fc" id="L118">        File newTempFile = File.createTempFile(&quot;sorted&quot;, &quot;.txt&quot;, tmpDirectory);</span>
<span class="fc" id="L119">        newTempFile.deleteOnExit();</span>
        // Write the tmp file to disk
<span class="fc" id="L121">        OutputStream out = new FileOutputStream(newTempFile);</span>
<span class="fc" id="L122">        BufferedWriter fileWriter = new BufferedWriter(new OutputStreamWriter(out));</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        for (String line : unsortedLineChunk) {</span>
<span class="fc" id="L124">            fileWriter.write(line);</span>
<span class="fc" id="L125">            fileWriter.newLine();</span>
<span class="fc" id="L126">        }</span>
<span class="fc" id="L127">        fileWriter.close();</span>
<span class="fc" id="L128">        return newTempFile;</span>
    }

    /**
    * This uses a min/max heap and the merge k sorted lists algorithm to merge the sorted temp files.
    *
    * Why use java.util.Scanner here instead of java.io.BufferedFileReader? The scanner uses
    * a smaller buffer than the buffered reader and since the files are sorted word for word, it is
    * more memory efficient to read a single word than to read a line chunk and split it into words
    *
    * @param comparator Comparator for merging the words in the sorted temp files
    * @param tmpFiles A list of the sorted temp files to be merged into output file
    * @param fileWriter A simple buffered file writer for writing the output file
    * @param wordWrap Number of words before wrapping to a new line
    *
    * @throws IOException General IOException if unable to access any file(s)
    * */
    public static void mergeSortedTempFiles(Comparator&lt;String&gt; comparator, List&lt;File&gt; tmpFiles,
        BufferedWriter fileWriter, int wordWrap) throws IOException {
        // Min/Max heap depending on the comparator passed
<span class="fc" id="L148">        PriorityQueue&lt;CachedScanner&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; comparator.compare(o1.peek(), o2.peek()));</span>
        // Add all the temp file scanners to the heap
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (File file : tmpFiles) {</span>
<span class="fc" id="L151">            Scanner s = new Scanner(file);</span>
<span class="fc" id="L152">            CachedScanner sc = new CachedScanner(s);</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            if (!sc.isEmpty()) {</span>
<span class="fc" id="L154">                queue.add(sc);</span>
            }
<span class="fc" id="L156">        }</span>
        // Go through heap and write the sorted words to output file
        // Wrapped in a try-finally block so if an exception occurs the file writer
        // and file scanners will always be closed
        try {
<span class="fc" id="L161">            int counter = 0;</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            while (!queue.isEmpty()) {</span>
<span class="fc" id="L163">                CachedScanner currScanner = queue.poll();</span>
<span class="fc" id="L164">                String word = currScanner.pop();</span>
<span class="fc" id="L165">                fileWriter.write(word);</span>
<span class="fc" id="L166">                fileWriter.write(&quot; &quot;);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                if (++counter &gt;= wordWrap) { // wrap line after wordWrap words per line</span>
<span class="fc" id="L168">                    fileWriter.newLine();</span>
<span class="fc" id="L169">                    counter = 0;</span>
                }
<span class="fc bfc" id="L171" title="All 2 branches covered.">                if (currScanner.isEmpty()) {</span>
<span class="fc" id="L172">                    currScanner.close();</span>
                } else {
<span class="fc" id="L174">                    queue.add(currScanner);</span>
                }
<span class="fc" id="L176">            }</span>
        } finally {
<span class="fc" id="L178">            fileWriter.close();</span>
            // Just in case an exception occurs before the priority queue is empty, to avoid any memory leaks
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            for (CachedScanner sc : queue) {</span>
<span class="nc" id="L181">                sc.close();</span>
<span class="nc" id="L182">            }</span>
        }
<span class="fc" id="L184">    }</span>

    /**
    * This method essentially takes a large file and scans a set block into memory
    * This block is then sorted and saved to a temp file. The list of temp files are
    * returned so they can be merged into a new output file
    *
    * @param fileSize Size of the input file, used to estimate block size
    * @param maxTmpFiles Maximum number of temporary files to create, used to estimate block size
    * @param freeMemory Estimated free memory, used to estimate block size
    * @param fileScanner Scanner for the input file to be sorted
    * @param comparator Comparator used to sort the words, ascending or descending order
    * @param tmpDirectory Directory to place the temp files, files will be deleted after
    *
    * @return The list of the sorted temp files
    *
    * @throws Exception If unable to read from the input file or save a temp file
    * */
    public static List&lt;File&gt; createSortedTempFiles(long fileSize, int maxTmpFiles, long freeMemory,
        Scanner fileScanner, Comparator&lt;String&gt; comparator, File tmpDirectory) throws Exception {
<span class="fc" id="L204">        List&lt;File&gt; files = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L205">        long maxBlockSize = getEstimatedBlockSize(fileSize, maxTmpFiles, freeMemory);</span>
<span class="fc" id="L206">        Set&lt;String&gt; distinctWords = new HashSet&lt;&gt;();</span>

        try {
<span class="fc bfc" id="L209" title="All 2 branches covered.">            while (fileScanner.hasNext()) {</span>
<span class="fc" id="L210">                long currBlockSize = 0;</span>
                // read lines from the file until we hit the max block size
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">                while (currBlockSize &lt; maxBlockSize &amp;&amp; fileScanner.hasNext()) {</span>
<span class="fc" id="L213">                    String word = fileScanner.next();</span>
<span class="fc" id="L214">                    distinctWords.add(word);</span>
<span class="fc" id="L215">                    currBlockSize += getEstimatedStringSize(word);</span>
<span class="fc" id="L216">                }</span>
<span class="fc" id="L217">                File currFile = sortAndSaveTempFile(new ArrayList&lt;&gt;(distinctWords), comparator, tmpDirectory);</span>
<span class="fc" id="L218">                files.add(currFile);</span>
<span class="fc" id="L219">                distinctWords.clear();</span>
<span class="fc" id="L220">                System.out.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
<span class="fc" id="L221">                        + &quot;: Temp file : &quot; + currFile.toString() + &quot; created successfully.&quot;);</span>
<span class="fc" id="L222">            }</span>
        } finally {
            // close the file scanner
<span class="fc" id="L225">            fileScanner.close();</span>
        }

<span class="fc" id="L228">        return files;</span>
    }

    public static void main(String[] args) throws Exception {
        // Internal default values
<span class="fc" id="L233">        long startTime = System.currentTimeMillis();</span>
<span class="fc" id="L234">        int maxTempFiles = 1024, wordWrap = 100;</span>
        File inputFile, outputFile;
<span class="fc" id="L236">        File tmpFilesDirectory = new File(&quot;.&quot;);</span>
<span class="fc" id="L237">        String order = &quot;asc&quot;;</span>

        // TODO - Replace with logger
<span class="fc" id="L240">        System.out.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
                + &quot;: Loading Configuration from File.&quot;);

        // Try to load configuration file, default to internal values if not found
        try {
<span class="fc" id="L245">            File configFile = new File(&quot;config.properties&quot;);</span>
<span class="fc" id="L246">            FileReader reader = new FileReader(configFile);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            if (props == null) {</span>
<span class="fc" id="L248">                props = new Properties();</span>
<span class="fc" id="L249">                props.load(reader);</span>
            }
<span class="fc" id="L251">            reader.close();</span>
<span class="nc" id="L252">        } catch (FileNotFoundException ex) {</span>
            // file does not exist continue with defaults
<span class="nc bnc" id="L254" title="All 2 branches missed.">            props = props == null ? new Properties() : props;</span>
<span class="nc" id="L255">            System.out.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
                    + &quot;: Configuration file not found. Using command line variables or internal defaults.&quot;);
<span class="nc" id="L257">        } catch (IOException ex) {</span>
            // I/O error continue with defaults
<span class="nc bnc" id="L259" title="All 2 branches missed.">            props = props == null ? new Properties() : props;</span>
<span class="nc" id="L260">            System.err.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
<span class="nc" id="L261">                    + &quot;: Unable to load configuration file: &quot; + ex.getMessage()</span>
                    + &quot;. Using command line variables or internal defaults&quot;);
<span class="pc" id="L263">        }</span>

        /*
        * Load configuration from config file or command line arguments
        * Order of precedence is command line &gt; config file &gt; internal defaults
        * */
        // config file
<span class="fc bfc" id="L270" title="All 2 branches covered.">        maxTempFiles = props.getProperty(&quot;maxTempFiles&quot;) != null ? Integer.parseInt(props.getProperty(&quot;maxTempFiles&quot;))</span>
            : maxTempFiles;
<span class="fc bfc" id="L272" title="All 2 branches covered.">        inputFile = props.getProperty(&quot;inputFile&quot;) != null ? new File(props.getProperty(&quot;inputFile&quot;))</span>
            : null;
<span class="fc bfc" id="L274" title="All 2 branches covered.">        outputFile = props.getProperty(&quot;outputFile&quot;) != null ? new File(props.getProperty(&quot;outputFile&quot;))</span>
            : null;
<span class="fc bfc" id="L276" title="All 2 branches covered.">        tmpFilesDirectory = props.getProperty(&quot;tmpFilesDirectory&quot;) != null ? new File(props.getProperty(&quot;tmpFilesDirectory&quot;))</span>
            : tmpFilesDirectory;
<span class="fc bfc" id="L278" title="All 2 branches covered.">        order = props.getProperty(&quot;order&quot;) != null ? props.getProperty(&quot;order&quot;) : order;</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        wordWrap = props.getProperty(&quot;wordWrap&quot;) != null ? Integer.parseInt(props.getProperty(&quot;wordWrap&quot;)) : wordWrap;</span>
        // command line
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (int param = 0; param &lt; args.length; param++) {</span>
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">            if (args[param].equals(&quot;--maxtmpfiles&quot;) &amp;&amp; args.length &gt; param + 1) {</span>
<span class="fc" id="L283">                int val = Integer.parseInt(args[++param]);</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                if (val &lt; 1) { // make sure it is valid</span>
<span class="fc" id="L285">                    System.err.println(&quot;Invalid max temp file value: &quot; + val</span>
                            + &quot;. Continuing with internal default: &quot; + maxTempFiles);
                } else {
<span class="fc" id="L288">                    maxTempFiles = val;</span>
                }
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">            } else if (args[param].equals(&quot;--tmpfilesdirectory&quot;) &amp;&amp; args.length &gt; param + 1) {</span>
<span class="fc" id="L291">                tmpFilesDirectory = new File(args[++param]);</span>
<span class="pc bpc" id="L292" title="1 of 4 branches missed.">            } else if (args[param].equals(&quot;--inputfile&quot;) &amp;&amp; args.length &gt; param + 1) {</span>
<span class="fc" id="L293">                inputFile = new File(args[++param]);</span>
<span class="pc bpc" id="L294" title="1 of 4 branches missed.">            } else if (args[param].equals(&quot;--outputfile&quot;) &amp;&amp; args.length &gt; param + 1) {</span>
<span class="fc" id="L295">                outputFile = new File(args[++param]);</span>
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">            } else if (args[param].equals(&quot;--order&quot;) &amp;&amp; args.length &gt; param + 1) {</span>
<span class="fc" id="L297">                order = args[++param];</span>
<span class="pc bpc" id="L298" title="2 of 4 branches missed.">            } else if (args[param].equals(&quot;--wordwrap&quot;) &amp;&amp; args.length &gt; param + 1) {</span>
<span class="fc" id="L299">                wordWrap = Integer.parseInt(args[++param]);</span>
            }
        }

        // Make sure none of the required values are null
<span class="pc bpc" id="L304" title="1 of 4 branches missed.">        if (inputFile == null || outputFile == null) {</span>
<span class="pc bpc" id="L305" title="2 of 4 branches missed.">            String message = &quot;The following parameters are required: &quot;</span>
                    + (inputFile == null ? &quot;Input file, &quot; : &quot;&quot;)
                    + (outputFile == null ? &quot;Output file&quot; : &quot;&quot;);
<span class="fc" id="L308">            System.err.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
                    + &quot;: &quot; + message);
<span class="fc" id="L310">            throw new Exception(message);</span>
        }

        // Sort ascending order or descending order
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">        Comparator&lt;String&gt; comparator = order.equals(&quot;desc&quot;) ? (a, b) -&gt; b.toLowerCase().compareTo(a.toLowerCase())</span>
<span class="fc" id="L315">                : (a, b) -&gt; a.toLowerCase().compareTo(b.toLowerCase());</span>

        // Split the input file into sorted temp files
<span class="fc" id="L318">        System.out.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
                + &quot;: Begin splitting large file into temporary sorted smaller files.&quot;);
<span class="fc" id="L320">        Scanner fileScanner = new Scanner(inputFile);</span>
<span class="fc" id="L321">        List&lt;File&gt; sortedTempFiles = createSortedTempFiles(inputFile.length(), maxTempFiles,</span>
<span class="fc" id="L322">                getEstimatedFreeMemory(), fileScanner, comparator, tmpFilesDirectory);</span>

        // Merge the sorted temp files
<span class="fc" id="L325">        System.out.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
<span class="fc" id="L326">                + &quot;: Begin merging temporary sorted files to sorted output file - &quot; + outputFile.toString());</span>
<span class="fc" id="L327">        BufferedWriter fileWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile, true)));</span>
<span class="fc" id="L328">        mergeSortedTempFiles(comparator, sortedTempFiles, fileWriter, wordWrap);</span>
<span class="fc" id="L329">        System.out.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
                + &quot;: Sorted output file created successfully.&quot;);
<span class="fc" id="L331">        System.out.println(new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss.sss&quot;).format(new Date())</span>
<span class="fc" id="L332">                + &quot;: Total processing time(ms) - &quot; + (System.currentTimeMillis() - startTime));</span>
<span class="fc" id="L333">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>